# ans 1:
""" arr1 = [i for i in range(1, 21) if i % 2 == 1]
arr2 = [i for i in range(1, 21) if i % 2 == 0]

for index in range(len(arr1)):
    print(arr1[index], '<--->', arr2[index]) """

# ans 2:
"""     arr1 = [i for i in range(1, 21, 2)]
arr2 = [i for i in range(2, 21, 2)]

for o, e in zip(arr1, arr2):
    print(o, e, sep=' <---> ') """


"""     這邊我們有幾個要點要注意。
首先，在創造元素的時候，其實基偶數的規則是可以用range表達出來的，因此我們不在List Comprehension裡面做if判斷。這樣除了程式碼比較精簡以外，效率也會提升喔!

接著我們來看看zip這個函式，這個函式會接受不限個數的序列容器，並把他們合而為一，成為一個超大的序列容器。
你可能會好奇她是怎麼做的，讓我們來看看一個實例：
假設你今天有兩個陣列，分別為

1, 2, 3, 4, 5
6, 7, 8, 9, 10
那麼zip就會產出一個這樣的序列容器
(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)
從上面例子可清楚看到，他會把兩個陣列的第一個元素取出，合併為一個tuple，並放進新的序列容器之中。然後第二個...第三個...以此類推。
你可能會好奇，如果給zip的序列容器不等長，結果會怎麼樣?
結果會是以最短的輸入容器為主，做出與之等長的新容器。 """

arr1 = [i for i in range(10)]
arr2 = [i for i in range(5, 15)]

for t in zip(arr1, arr2):
    print(t[0], t[1])
print('*' * 10)

for i, j in zip(arr1, arr2):
    print(i, j)
print('*' * 10)

""" 第一種方法，直接用一個變數接住tuple，再用index取值。
第二種方法，既然事先知道壓縮了幾個容器，也就知道裡面tuple的長度，
因此用一樣多的變數接住他 (以上面例子來說，要用兩個變數i, j。

最後最後，教教大家怎麼很潮的使用print。
其實同時輸出值的時候，中間不一定要用空白隔開，
你可以給print函式sep這個參數，如此一來就可以用自己喜歡的方式隔開輸出值了! """